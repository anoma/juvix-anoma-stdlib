module Specs;

import Stdlib.Prelude open public;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};
import Data.Set as Set open public;
import Data.Map as Map open using {Map};

module MathematicalProperty;
  trait
  type AdditivelyHomomorphic T := mkAdditivelyHomomorphic {add : T -> T -> T};

  Property-AdditivelyHomomorphic
    {T} {{Eq T}} {{AdditivelyHomomorphic T}} (f : T -> T) (x y : T) : Bool :=
    f (AdditivelyHomomorphic.add x y) == AdditivelyHomomorphic.add (f x) (f y);

  trait
  type KindDistinct T := mkKindDistinct {add : T -> T -> T};
end;

module Delta;
  axiom Delta : Type;

  axiom addDelta : Delta -> Delta -> Delta;

  axiom zero : Delta;

  instance
  Delta-AdditivelyHomomorphic : MathematicalProperty.AdditivelyHomomorphic Delta :=
    MathematicalProperty.mkAdditivelyHomomorphic@{
      add (a b : Delta) : Delta := addDelta a b
    };

  instance
  Delta-KindDistinct : MathematicalProperty.KindDistinct Delta :=
    MathematicalProperty.mkKindDistinct@{
      add (a b : Delta) : Delta := addDelta a b
    };
end;

open Delta using {Delta} public;

module Resource;

  axiom LogicRef : Type;

  axiom LabelRef : Type;

  axiom ValueRef : Type;

  axiom Quantity : Type;

  axiom NullifierKey : Type;

  axiom NullifierKeyCommitment : Type;

  axiom Nonce : Type;

  axiom RandSeed : Type;

  type Resource :=
    mkResource {
      logicRef : LogicRef;
      labelRef : LabelRef;
      valueRef : ValueRef;
      quantity : Quantity;
      ephemerality : Bool;
      nullifierKeyCommitment : NullifierKeyCommitment;
      nonce : Nonce;
      randSeed : RandSeed
    };

  module Kind;
    axiom Kind : Type;

    open Resource;

    axiom _kind : (logicRef : LogicRef) -> (labelRef : LabelRef) -> Kind;

    kind (resource : Resource) : Kind :=
      _kind@{
        logicRef := Resource.logicRef resource;
        labelRef := Resource.labelRef resource
      };
  end;

  open Kind using {Kind; kind} public;

  module Delta;
    axiom _delta : (kind : Kind) -> (quantity : Quantity) -> Delta;

    delta (resource : Resource) : Delta := _delta (kind resource) (Resource.quantity resource);
  {- @{ kind := kind resource; quantity := Resource.quantity resource}; -}
  end;

  open Delta using {delta} public;

  module Commitment;
    axiom Commitment : Type;

    axiom commitment : (resource : Resource) -> Commitment;

    axiom compare : Commitment -> Commitment -> Ordering;

    instance
    Commitment-Ord : Ord Commitment :=
      mkOrd@{
        cmp := compare
      };

    instance
    Commitment-Eq : Eq Commitment := fromOrdToEq;

  end;

  open Commitment using {Commitment; commitment} public;

  module Nullifier;
    axiom Nullifier : Type;

    axiom nullifier : (resource : Resource) -> (nullifierKey : NullifierKey) -> Nullifier;

    axiom compare : Nullifier -> Nullifier -> Ordering;

    instance
    Nullifier-Ord : Ord Nullifier :=
      mkOrd@{
        cmp := compare
      };

    instance
    Nullifier-Eq : Eq Nullifier := fromOrdToEq;
  end;

  open Nullifier using {Nullifier; nullifier} public;

  Logic : Type := Tag -> Instance -> Witness -> Bool;

  axiom logicRef : Logic -> LogicRef;

  --- The reference to the ;Resource; carrying the ;Logic; function.
  type Tag :=
    | Created Commitment
    | Consumed Nullifier;

  --- The public inputs to the ;Logic; function.
  type Instance :=
    mkInstance {
      commitments : Set Commitment;
      nullifiers : Set Nullifier;
      tag : Tag;
      custom : CustomInstance
    };

  axiom CustomInstance : Type;

  --- The private inputs to the ;Logic; function.
  type Witness :=
    mkWitness {
      created : Set Resource;
      consumed : Set Resource;
      custom : CustomWitness
    };

  axiom CustomWitness : Type;

end;

open Resource using {Resource} public;

module CommitmentTree;
  axiom Root : Type;

  axiom Path : Type;

  positive
  trait
  type CommitmentTree :=
    mkCommitmentTree {
      add : CommitmentTree -> Resource.Commitment -> Path;
      path : CommitmentTree -> Resource.Commitment -> Maybe Path;
      verify : Resource.Commitment -> Path -> Root -> Bool;
      root : CommitmentTree -> Root
    };
end;

module NullfifierSet;
  trait
  type NullfifierSet :=
    mkAccumulator {
      add : Resource.Nullifier -> NullfifierSet;
      exists : Resource.Nullifier -> Bool
    };
end;

module ProvingSystem;
  axiom Proof : Type;

  axiom VerifyingKey : Type;

  axiom ProvingKey : Type;

  ProofRecord : Type := Pair VerifyingKey (Pair Proof Resource.Witness);

  trait
  type ProvingSystem :=
    mkProvingSystem {
      prove : ProvingKey -> Resource.Instance -> Resource.Witness -> Proof;
      verify : ProofRecord -> Bool
    };
end;

module Transaction;
  axiom AppDataKeyType : Type;

  axiom AppDataValueType : Type;

  AppDataMap : Type := Set (Pair AppDataKeyType AppDataValueType);

  module Action;
    type Action :=
      mkAction {
        commitments : Set Resource.Commitment;
        nullifiers : Set Resource.Nullifier;
        proofs : Set ProvingSystem.ProofRecord;
        appData : AppDataMap
      };
  end;

  open Action using {Action} public;

  axiom UnitInterval : Type;

  Preference : Type := Transaction -> UnitInterval;

  positive
  type Transaction :=
    mkTransaction {
      roots : Set CommitmentTree.Root;
      actions : Set Action;
      delta : Delta;
      preference : Preference
    };

  module Delta;
    isInCommitmentSet (resource : Resource) (transaction : Transaction) : Bool :=
      let
        actions : List Action := Set.toList (Transaction.actions transaction);
        cm : Resource.Commitment := Resource.commitment resource;
        cms : Set Resource.Commitment :=
          for (acc := Set.empty) (a in actions) {union acc (Action.Action.commitments a)};
      in member? cm cms;

    isInNullifierSet
      (resource : Resource)
      (nullifierKey : Resource.NullifierKey)
      (transaction : Transaction)
      : Bool :=
      let
        actions : Set Action := Transaction.actions transaction;
        nf : Resource.Nullifier :=
          Resource.nullifier@{
            resource;
            nullifierKey
          };
        nfs : Set Resource.Nullifier :=
          for (acc := Set.empty) (a in actions) {union acc (Action.Action.nullifiers a)};

      in member? nf nfs;

    delta
      (resources : Set Resource)
      (nullifierKey : Resource.NullifierKey)
      (transaction : Transaction)
      : Delta :=
      for (acc := Delta.zero) (r in resources)
        {if
          | isInCommitmentSet@{
              resource := r;
              transaction
            }
            || isInNullifierSet@{
              resource := r;
              nullifierKey;
              transaction
            } := MathematicalProperty.AdditivelyHomomorphic.add acc (Resource.delta r)
          | else := acc};
  end;
end;

open Transaction using {Transaction} public;

-- TODO Continue here
{-
module Machine;
  trait
  type Machine :=
    mkMachine {
      create : Set CommitmentTree.Root
        -> Set Transaction.Action
        -> Delta
        -> Transaction.Preference
        -> Transaction;
      compose : Transaction -> Transaction -> Transaction;
      verify : Transaction.Transaction -> Bool

    };
end;
open Machine using {Machine} public;
-}
